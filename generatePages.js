// Explanation of code
// Ahmed Hussein 2000-07-30
// This script takes a JSON bundle generated by a Python script and injects it into the React application.

const fs = require('fs');
const path = require('path');
const os = require('os');

// === Config ===
const TAG_COLUMNS = [
  "Garo",
  "S√§kerhet",
  "Drifts√§kerhet",
  "Installation",
  "Anv√§ndarv√§nlighet",
  "Smarta funktioner",
  "Ekonomi"
];

const isPackaged = process.pkg != null;
const exeDir = isPackaged ? path.dirname(process.execPath) : __dirname;
const garoRoot = path.resolve(exeDir);
const jsonDir = path.join(garoRoot, 'resource json');
const outputDir = path.join(garoRoot, 'Front_end', 'info-page', 'src', 'generated');
const brodtextPath = path.join(exeDir, 'br√∂dtext.txt');
const brodtextOutput = path.join(outputDir, 'brodtext.js');

function sanitizeComponentName(name) {
  return name
    .normalize('NFD').replace(/[ÃÄ-ÕØ]/g, '')
    .replace(/[^a-zA-Z0-9]/g, '')
    .replace(/^[0-9]+/, '')
    .trim();
}

function getLocalIPv4() {
  const networkInterfaces = os.networkInterfaces();
  const preferredPrefixes = ['192.', '10.'];

  for (const iface of Object.values(networkInterfaces)) {
    for (const net of iface) {
      if (
        net.family === 'IPv4' &&
        !net.internal &&
        preferredPrefixes.some(prefix => net.address.startsWith(prefix))
      ) {
        return net.address;
      }
    }
  }

  for (const iface of Object.values(networkInterfaces)) {
    for (const net of iface) {
      if (net.family === 'IPv4' && !net.internal) {
        return net.address;
      }
    }
  }

  return 'localhost';
}

const localIP = getLocalIPv4();

// === Clean and recreate 'generated' folder ===
if (fs.existsSync(outputDir)) {
  fs.rmSync(outputDir, { recursive: true, force: true });
  console.log("üóëÔ∏è Removed previous 'generated' folder to start fresh.");
}
fs.mkdirSync(outputDir, { recursive: true });
TAG_COLUMNS.forEach(tag => {
  fs.mkdirSync(path.join(outputDir, tag), { recursive: true });
});

const routesList = JSON.parse(fs.readFileSync(path.join(jsonDir, 'routes.json'), 'utf-8'));
const tagCounts = {};
const tagRoutesMap = {};
const usedTags = new Set();

routesList.forEach(route => {
  const filePath = path.join(jsonDir, route.file);
  if (!fs.existsSync(filePath)) return;

  const data = JSON.parse(fs.readFileSync(filePath, 'utf-8'));
  const safeName = sanitizeComponentName(data.egenskap || 'Unnamed');
  const componentName = `${safeName}Page`;
  const componentFile = `${componentName}.js`;

  const fields = [
    { label: "Kundf√∂rdel", value: data.fordel },
    { label: "T√§nkbar Nytta", value: data.nytta },
    { label: "T√§nkbara Problem", value: data.problem },
    { label: "Anledning", value: data.anledning },
    { label: "V√§rde", value: data.cost },
    { label: "Beskrivning", value: data.beskrivning }
  ];

  const componentContent = `
import React from 'react';
export const tags = ${JSON.stringify(data.tags || [])};

export default function ${componentName}() {
  const fields = ${JSON.stringify(fields)}.filter(f => f.value && f.value !== "Inget inneh√•ll" && f.value !== "nan");

  return (
    <div>
      <h1>${data.egenskap}</h1>
      {fields.map((field, i) => (
        <p key={i}><strong>{field.label}:</strong> {field.value}</p>
      ))}
      ${data.reference && data.reference !== "nan" ? `<p><strong>L√§s mer h√§r:</strong> <a href="${data.reference}" target="_blank" rel="noopener noreferrer">${data.reference}</a></p>` : ''}
    </div>
  );
}`.trim();

  (data.tags || []).forEach(tag => {
    if (!TAG_COLUMNS.includes(tag)) return;

    usedTags.add(tag);
    const tagFolder = path.join(outputDir, tag);
    fs.writeFileSync(path.join(tagFolder, componentFile), componentContent, 'utf-8');

    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
    tagRoutesMap[tag] = tagRoutesMap[tag] || [];

    if (data.egenskap === "Garo" && tag === "Garo") {
      tagRoutesMap[tag].unshift({ ...route, component: componentFile });
    } else {
      tagRoutesMap[tag].push({ ...route, component: componentFile });
    }
  });
});

TAG_COLUMNS.forEach(tag => {
  const routes = tagRoutesMap[tag] || [];
  const content = `const routes = ${JSON.stringify(routes, null, 2)};

export default routes;`;
  fs.writeFileSync(path.join(outputDir, tag, 'Routes.js'), content, 'utf-8');
});

fs.writeFileSync(path.join(outputDir, 'tagCounts.json'), JSON.stringify(tagCounts, null, 2), 'utf-8');

const brodRaw = fs.readFileSync(brodtextPath, 'utf-8').replace(/\r/g, '');
const brodMap = {};
let entityName = '';

brodRaw.split('\n').forEach(line => {
  const [key, ...rest] = line.split(':');
  if (key && rest.length > 0) {
    const trimmedKey = key.trim();
    const value = rest.join(':').trim();
    brodMap[trimmedKey] = value;
    if (trimmedKey === "Namn") {
      entityName = value;
    }
  }
});

fs.writeFileSync(brodtextOutput, `const BRODTEXT = ${JSON.stringify(brodMap, null, 2)};\n\nexport default BRODTEXT;\n`, 'utf-8');

if (entityName) {
  const entityJS = `const ENTITY_NAME = ${JSON.stringify(entityName)};\n\nexport default ENTITY_NAME;\n`;
  fs.writeFileSync(path.join(outputDir, 'entityName.js'), entityJS, 'utf-8');
}

const qrComponent = `
import React from 'react';
import { QRCodeSVG } from 'qrcode.react';

export default function QRCodeComponent() {
  return (
    <div style={{ textAlign: 'center', marginTop: '2rem' }}>
      <p style={{ fontSize: '1.5rem' }}>Skanna QR-koden f√∂r att √∂ppna sidan p√• mobilen:</p>
      <QRCodeSVG value="http://${localIP}:3000" size={180} />
    </div>
  );
}`.trim();

fs.writeFileSync(path.join(outputDir, 'qrCode.js'), qrComponent, 'utf-8');
console.log("‚úÖ All components and files generated successfully.");
console.log("üåê QR Code points to: http://" + localIP + ":3000");
